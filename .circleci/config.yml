version: 2.1

aliases:
  keychain: &keychain
    run:
      name: Add cert to the keychain
      command: |
        security create-keychain -p mysecretpassword $KEYCHAIN
        security default-keychain -s $KEYCHAIN
        security unlock-keychain -p mysecretpassword $KEYCHAIN
        security set-keychain-settings -u -t 10000000 $KEYCHAIN
        security import certs/mac-developer.p12 -k $KEYCHAIN -P "$CSC_KEY_PASSWORD" -T /usr/bin/codesign -T /usr/bin/productbuild
        security import certs/mas-distribution.p12 -k $KEYCHAIN -P "$CSC_MAS_PASSWORD" -T /usr/bin/codesign -T /usr/bin/productbuild
        security import certs/mac-installer.p12 -k $KEYCHAIN -P "$CSC_MAC_INSTALLER_PASSWORD" -T /usr/bin/codesign -T /usr/bin/productbuild
        security set-key-partition-list -S apple-tool:,apple: -s -k mysecretpassword $KEYCHAIN
      environment:
        KEYCHAIN: redisinsight.keychain
  import: &import
    run:
      name: User certutil to import certificate
      command: certutil -p %WIN_CSC_KEY_PASSWORD% -importpfx certs\redislabs_win.pfx
      shell: cmd.exe
  sign: &sign
    run:
      name: Sign application
      command: |
        $filePath = $(Get-ChildItem release -Filter RedisInsight*.exe | % { $_.FullName })
        $filePathWithQuotes = '"{0}"' -f $filePath
        & "C:\Program Files (x86)\Windows Kits\10\bin\10.0.19041.0\x86\signtool.exe" sign /a /sm /n "Redis Labs Inc." /fd sha256 /tr http://sha256timestamp.ws.symantec.com/sha256/timestamp /v $FilePathWithQuotes
      shell: powershell.exe
  scan: &scan
    run:
      name: Virustotal scan
      command: &virusscan |
        uploadUrl=$(curl -sq -XGET https://www.virustotal.com/api/v3/files/upload_url -H "x-apikey: $VIRUSTOTAL_API_KEY" | jq -r '.data')
        uploadFile=$("/usr/bin/find" /tmp/release -name ${FILE_NAME})
        echo "File to upload: ${uploadFile}"
        analysedId=$(curl -sq -XPOST "${uploadUrl}" -H "x-apikey: $VIRUSTOTAL_API_KEY" --form file=@"${uploadFile}" | jq -r '.data.id')
        if [ $analysedId == "null" ]; then
          echo 'Status is null, something went wrong'; exit 1;
        fi
        echo "export ANALYZED_ID=${analysedId}" >> $BASH_ENV
        echo "Virustotal Analyzed id: ${analysedId}"
        sleep 10
      shell: /bin/bash
  validate: &validate
    run:
      name: Virustotal validate scan results
      command: &virusValidate |
        analyzeStatus=$(curl -sq -XGET https://www.virustotal.com/api/v3/analyses/${ANALYZED_ID} -H "x-apikey: $VIRUSTOTAL_API_KEY" | jq -r '.data.attributes.status')
        if [ $analyzeStatus == "null" ]; then
          echo 'Status is null, something went wrong'; exit 1;
        fi

        currentOperation="50"
        until [ "$currentOperation" == "0" ]; do
          if [ "$analyzeStatus" == "completed" ]
          then
            echo "Current status: ${analyzeStatus}"; break;
          else
            echo "Current status: ${analyzeStatus}, retries left: ${currentOperation} ";
            analyzeStatus=$(curl -sq -XGET https://www.virustotal.com/api/v3/analyses/${ANALYZED_ID} -H "x-apikey: $VIRUSTOTAL_API_KEY" | jq -r '.data.attributes.status');
            sleep 20;
            currentOperation=$[$currentOperation - 1];
          fi
        done

        analyzeStats=$(curl -sq -XGET https://www.virustotal.com/api/v3/analyses/${ANALYZED_ID} -H "x-apikey: $VIRUSTOTAL_API_KEY" | jq -r '.data.attributes.stats')
        analazedHarmless=$(echo ${analyzeStats} | jq '.harmless')
        analazedMalicious=$(echo ${analyzeStats} | jq '.malicious')
        analazedSuspicious=$(echo ${analyzeStats} | jq '.suspicious')

        if [ "$analyzeStatus" != "completed" ]; then
          echo 'Analyse is not completed'; exit 1;
        fi
        echo "Results:"
        echo "analazedHarmless: ${analazedHarmless}, analazedMalicious:  ${analazedMalicious}, analazedSuspicious: ${analazedSuspicious}"

        if [ "$analazedHarmless" != "0" ] || [ "$analazedMalicious" != "0" ] || [ "$analazedSuspicious" != "0" ]; then
          echo 'Found dangers'; exit 1;
        fi

        echo 'Passed';
      shell: /bin/bash
      no_output_timeout: 15m
  iTestsNames: &iTestsNames
    - oss-st-5            # OSS Standalone v5
    - oss-st-5-pass       # OSS Standalone v5 with admin pass required
    - oss-st-6            # OSS Standalone v6 and all modules
    - oss-st-big          # OSS Standalone v6 and all modules and predefined amount of data inside (~3-4M)
    - mods-preview        # OSS Standalone and all preview modules
    - oss-st-6-tls        # OSS Standalone v6 with TLS enabled
    - oss-st-6-tls-auth   # OSS Standalone v6 with TLS auth required
    - oss-st-6-tls-auth-ssh   # OSS Standalone v6 with TLS auth required through ssh
    - oss-clu             # OSS Cluster
    - oss-clu-tls         # OSS Cluster with TLS enabled
    - oss-sent            # OSS Sentinel
    - oss-sent-tls-auth   # OSS Sentinel with TLS auth
    - re-st               # Redis Enterprise with Standalone inside
    - re-clu              # Redis Enterprise with Cluster inside
    - re-crdt             # Redis Enterprise with active-active database inside
  iTestsNamesShort: &iTestsNamesShort
    - oss-st-5-pass       # OSS Standalone v5 with admin pass required
    - oss-st-6-tls-auth   # OSS Standalone v6 with TLS auth required
    - oss-clu-tls         # OSS Cluster with TLS enabled
    - re-crdt             # Redis Enterprise with active-active database inside
    - oss-sent-tls-auth   # OSS Sentinel with TLS auth
  guides-filter: &guidesFilter
    filters:
      branches:
        only:
          - guides
  dev-filter: &devFilter
    filters:
      branches:
        only:
          - main
          - /^build\/.*/
  stage-filter: &stageFilter
    filters:
      branches:
        only:
          - /^release.*/
  prod-filter: &prodFilter
    filters:
      branches:
        only:
          - latest
  ui-deps-cache-key: &uiDepsCacheKey
    key: v1-ui-deps-{{ checksum "yarn.lock" }}
  api-deps-cache-key: &apiDepsCacheKey
    key: v1-ui-deps-{{ checksum "redisinsight/api/yarn.lock" }}

orbs:
  win: circleci/windows@2.4.1
  node: circleci/node@5.0.2
  aws: circleci/aws-cli@2.0.3

executors:
  linux-executor:
    machine:
      image: ubuntu-2004:202010-01
  linux-executor-dlc:
    machine:
      image: ubuntu-2004:202010-01
      docker_layer_caching: true

jobs:
  # Test jobs
  unit-tests-ui:
    docker:
      - image: cimg/node:16.15.1
    steps:
      - checkout
      - restore_cache:
          <<: *uiDepsCacheKey
      - run:
          name: UI PROD dependencies audit
          command: |
            FILENAME=ui.prod.deps.audit.json
            yarn audit --groups dependencies --json > $FILENAME || true &&
            FILENAME=$FILENAME DEPS="UI prod" node .circleci/deps-audit-report.js &&
            curl -H "Content-type: application/json" --data @slack.$FILENAME -H "Authorization: Bearer ${SLACK_AUDIT_REPORT_KEY}" -X POST https://slack.com/api/chat.postMessage
      - run:
          name: UI DEV dependencies audit
          command: |
            FILENAME=ui.dev.deps.audit.json
            yarn audit --groups devDependencies --json > $FILENAME || true &&
            FILENAME=$FILENAME DEPS="UI dev" node .circleci/deps-audit-report.js &&
            curl -H "Content-type: application/json" --data @slack.$FILENAME -H "Authorization: Bearer ${SLACK_AUDIT_REPORT_KEY}" -X POST https://slack.com/api/chat.postMessage
      - run:
          name: Code analysis
          command: |
            SKIP_POSTINSTALL=1 yarn install

            FILENAME=ui.lint.audit.json
            WORKDIR="."
            yarn lint:ui -f json -o $FILENAME || true &&
            FILENAME=$FILENAME WORKDIR=$WORKDIR TARGET="UI" node .circleci/lint-report.js &&
            curl -H "Content-type: application/json" --data @$WORKDIR/slack.$FILENAME -H "Authorization: Bearer ${SLACK_AUDIT_REPORT_KEY}" -X POST https://slack.com/api/chat.postMessage

            FILENAME=rest.lint.audit.json
            yarn lint -f json -o $FILENAME || true &&
            FILENAME=$FILENAME WORKDIR=$WORKDIR TARGET="REST" node .circleci/lint-report.js &&
            curl -H "Content-type: application/json" --data @$WORKDIR/slack.$FILENAME -H "Authorization: Bearer ${SLACK_AUDIT_REPORT_KEY}" -X POST https://slack.com/api/chat.postMessage
      - run:
          name: Unit tests UI
          command: |
            yarn test:cov --ci
      - save_cache:
          <<: *uiDepsCacheKey
          paths:
            - ./node_modules
  unit-tests-api:
    docker:
      - image: cimg/node:16.15.1
    steps:
      - checkout
      - restore_cache:
          <<: *apiDepsCacheKey
      - run:
          name: API PROD dependencies scan
          command: |
            FILENAME=api.prod.deps.audit.json
            yarn --cwd redisinsight/api audit --groups dependencies --json > $FILENAME || true &&
            FILENAME=$FILENAME DEPS="API prod" node .circleci/deps-audit-report.js &&
            curl -H "Content-type: application/json" --data @slack.$FILENAME -H "Authorization: Bearer ${SLACK_AUDIT_REPORT_KEY}" -X POST https://slack.com/api/chat.postMessage
      - run:
          name: API DEV dependencies scan
          command: |
            FILENAME=api.dev.deps.audit.json
            yarn --cwd redisinsight/api audit --groups devDependencies --json > $FILENAME || true &&
            FILENAME=$FILENAME DEPS="API dev" node .circleci/deps-audit-report.js &&
            curl -H "Content-type: application/json" --data @slack.$FILENAME -H "Authorization: Bearer ${SLACK_AUDIT_REPORT_KEY}" -X POST https://slack.com/api/chat.postMessage
      - run:
          name: Code analysis
          command: |
            yarn --cwd redisinsight/api

            FILENAME=api.lint.audit.json
            WORKDIR="./redisinsight/api"
            yarn lint:api -f json -o $FILENAME || true &&
            FILENAME=$FILENAME WORKDIR=$WORKDIR TARGET="API" node .circleci/lint-report.js &&
            curl -H "Content-type: application/json" --data @$WORKDIR/slack.$FILENAME -H "Authorization: Bearer ${SLACK_AUDIT_REPORT_KEY}" -X POST https://slack.com/api/chat.postMessage
      - run:
          name: Unit tests API
          command: |
            yarn --cwd redisinsight/api/ test:cov --ci
      - save_cache:
          <<: *apiDepsCacheKey
          paths:
            - ./redisinsight/api/node_modules
  integration-tests-run:
    executor: linux-executor-dlc
    parameters:
      rte:
        description: Redis Test Environment name
        type: string
      build:
        description: Backend build to run tests over
        type: enum
        default: local
        enum: ['local', 'docker', 'saas']
      report:
        description: Send report for test run to slack
        type: boolean
        default: false
    steps:
      - checkout
      - restore_cache:
          <<: *apiDepsCacheKey
      - when:
          condition:
            equal: [ 'docker', << parameters.build >> ]
          steps:
            - attach_workspace:
                at: /tmp
            - run:
                name: Load built docker image from workspace
                command: |
                  docker image load -i /tmp/docker-release/docker.tar
      - run:
          name: Run tests
          command: |
            ./redisinsight/api/test/test-runs/start-test-run.sh -r << parameters.rte >> -t << parameters.build >>
            mkdir -p mkdir itest/coverages && mkdir -p itest/results
            cp ./redisinsight/api/test/test-runs/coverage/test-run-result.json ./itest/results/<< parameters.rte >>.result.json
            cp ./redisinsight/api/test/test-runs/coverage/test-run-result.xml ./itest/results/<< parameters.rte >>.result.xml
            cp ./redisinsight/api/test/test-runs/coverage/test-run-coverage.json ./itest/coverages/<< parameters.rte >>.coverage.json
      - when:
          condition:
            equal: [ true, << parameters.report >> ]
          steps:
            - run:
                name: Send report
                when: always
                command: |
                  ITEST_NAME=<< parameters.rte >> node ./.circleci/itest-results.js
                  curl -H "Content-type: application/json" --data @itests.report.json -H "Authorization: Bearer $SLACK_TEST_REPORT_KEY" -X POST https://slack.com/api/chat.postMessage
      - store_test_results:
          path: ./itest/results
      - persist_to_workspace:
          root: .
          paths:
            - ./itest/results/<< parameters.rte >>.result.json
            - ./itest/coverages/<< parameters.rte >>.coverage.json
  integration-tests-coverage:
    executor: linux-executor
    steps:
      - checkout
      - attach_workspace:
          at: /tmp
      - run:
          name: Calculate coverage across all tests runs
          command: |
            sudo mkdir -p /usr/src/app
            sudo cp -a ./redisinsight/api/. /usr/src/app/
            sudo cp -R /tmp/itest/coverages /usr/src/app && sudo chmod 777 -R /usr/src/app
            cd /usr/src/app && npx nyc report -t ./coverages -r text -r text-summary
  e2e-app-image:
    executor: linux-executor-dlc
    parameters:
      report:
        description: Send report for test run to slack
        type: boolean
        default: false
      parallelism:
        description: Number of threads to run tests
        type: integer
        default: 1
    parallelism: << parameters.parallelism >>
    steps:
      - checkout
      - attach_workspace:
          at: .
      - run: sudo apt-get install net-tools
      - run:
          name: .AppImage tests
          command: |
            cd tests/e2e && export TEST_FILES=$(circleci tests glob "tests/**/*.e2e.ts" | circleci tests split --split-by=timings) && cd ../..
            .circleci/e2e/test.app-image.sh
      - when:
          condition:
            equal: [ true, << parameters.report >> ]
          steps:
            - run:
                name: Send report
                when: always
                command: |
                  APP_BUILD_TYPE="Electron (Linux)" node ./.circleci/e2e-results.js
                  curl -H "Content-type: application/json" --data @e2e.report.json -H "Authorization: Bearer $SLACK_TEST_REPORT_KEY" -X POST https://slack.com/api/chat.postMessage
      - store_test_results:
          path: ./tests/e2e/results
      - store_artifacts:
          path: tests/e2e/report
          destination: tests/e2e/report
  e2e-exe:
    executor:
      name: win/default
    parameters:
      report:
        description: Send report for test run to slack
        type: boolean
        default: false
      parallelism:
        description: Number of threads to run tests
        type: integer
        default: 1
    parallelism: << parameters.parallelism >>
    steps:
      - checkout
      - attach_workspace:
          at: .
      - run: choco install nodejs --version=16.15.1
      - run:
          command: |
            cd tests/e2e && export TEST_FILES=$(circleci tests glob "tests/**/*.e2e.ts" | circleci tests split --split-by=timings) && cd ../..
            .circleci/e2e/test.exe.cmd
          shell: bash.exe
      - when:
          condition:
            equal: [ true, << parameters.report >> ]
          steps:
            - run:
                name: Send report
                when: always
                command: |
                  APP_BUILD_TYPE="Electron (Windows)" node ./.circleci/e2e-results.js
                  curl -H "Content-type: application/json" --data @e2e.report.json -H "Authorization: Bearer $SLACK_TEST_REPORT_KEY" -X POST https://slack.com/api/chat.postMessage
                shell: bash.exe
      - store_test_results:
          path: ./tests/e2e/results
      - store_artifacts:
          path: tests/e2e/report
          destination: tests/e2e/report
  e2e-tests:
    executor: linux-executor-dlc
    parameters:
      build:
        description: Backend build to run tests over
        type: enum
        default: local
        enum: ['local', 'docker']
      report:
        description: Send report for test run to slack
        type: boolean
        default: false
      parallelism:
        description: Number of threads to run tests
        type: integer
        default: 1
    parallelism: << parameters.parallelism >>
    steps:
      - checkout
      - when:
          condition:
            equal: [ 'docker', << parameters.build >> ]
          steps:
            - attach_workspace:
                at: /tmp
            - run:
                name: Load built docker image from workspace
                command: |
                  docker image load -i /tmp/docker-release/docker.tar
            - run:
                name: Run tests
                command: |
                  cd tests/e2e && export TEST_FILES=$(circleci tests glob "tests/**/*.e2e.ts" | circleci tests split --split-by=timings) && cd ../..
                  TEST_BIG_DB_DUMP=$TEST_BIG_DB_DUMP \
                  docker-compose \
                  -f tests/e2e/rte.docker-compose.yml \
                  -f tests/e2e/docker.web.docker-compose.yml \
                  up --abort-on-container-exit --force-recreate --build
                no_output_timeout: 5m
      - when:
          condition:
            equal: [ 'local', << parameters.build >> ]
          steps:
            - run:
                name: Run tests
                command: |
                  cd tests/e2e && export TEST_FILES=$(circleci tests glob "tests/**/*.e2e.ts" | circleci tests split --split-by=timings) && cd ../..
                  TEST_BIG_DB_DUMP=$TEST_BIG_DB_DUMP \
                  docker-compose \
                  -f tests/e2e/rte.docker-compose.yml \
                  -f tests/e2e/local.web.docker-compose.yml \
                  up --abort-on-container-exit --force-recreate
                no_output_timeout: 5m
      - when:
          condition:
            equal: [ true, << parameters.report >> ]
          steps:
            - run:
                name: Send report
                when: always
                command: |
                  node ./.circleci/e2e-results.js
                  curl -H "Content-type: application/json" --data @e2e.report.json -H "Authorization: Bearer $SLACK_TEST_REPORT_KEY" -X POST https://slack.com/api/chat.postMessage
      - store_test_results:
          path: ./tests/e2e/results
      - store_artifacts:
          path: tests/e2e/report
          destination: tests/e2e/report

  # Build jobs
  setup-sign-certificates:
    executor: linux-executor
    steps:
      - run:
          name: Setup sign certificates
          command: |
            mkdir -p certs
            echo "$CSC_P12_BASE64" | base64 -id > certs/mac-developer.p12
            echo "$CSC_MAC_INSTALLER_P12_BASE64" | base64 -id > certs/mac-installer.p12
            echo "$CSC_MAS_P12_BASE64" | base64 -id > certs/mas-distribution.p12
            echo "$WIN_CSC_PFX_BASE64" | base64 -id > certs/redislabs_win.pfx
      - persist_to_workspace:
          root: .
          paths:
            - certs
  setup-build:
    parameters:
      env:
        description: Build environment (stage || prod)
        type: enum
        default: stage
        enum: [ 'dev', 'stage', 'prod' ]
    docker:
      - image: cibuilds/docker:19.03.5
    steps:
      - checkout
      - run:
          command: |
            mkdir electron

            CURRENT_VERSION=$(jq -r ".version" redisinsight/package.json)
            echo "Build version: $CURRENT_VERSION"
            cp ./redisinsight/package.json ./electron/package.json
            echo "$VERSION" > electron/version
            exit 0

      - persist_to_workspace:
          root: /root/project
          paths:
            - electron
  linux:
    machine:
      image: ubuntu-2004:202101-01
    resource_class: large
    parameters:
      env:
        description: Build environment (stage || prod)
        type: enum
        default: stage
        enum: ['stage', 'prod', 'dev']
      redisstack:
        description: Build RedisStack archives
        type: boolean
        default: true
    steps:
      - checkout
      - node/install:
          node-version: '16.15.1'
      - attach_workspace:
          at: .
      - run:
          command: |
            cp ./electron/package.json ./redisinsight/
      - run:
          name: install dependencies
          command: |
            sudo apt-get update -y && sudo apt-get install -y rpm flatpak flatpak-builder ca-certificates
            flatpak remote-add --user --if-not-exists flathub https://dl.flathub.org/repo/flathub.flatpakrepo
            flatpak install flathub --no-deps --arch x86_64 --assumeyes \
            runtime/org.freedesktop.Sdk/x86_64/20.08 \
            runtime/org.freedesktop.Platform/x86_64/20.08 \
            org.electronjs.Electron2.BaseApp/x86_64/20.08

            yarn --cwd redisinsight/api/ install --ignore-optional
            yarn --cwd redisinsight/ install --ignore-optional
            yarn install
            yarn build:statics
          no_output_timeout: 15m
      - run:
          name: Build linux AppImage and deb
          command: |
            if [ << parameters.env >> == 'prod' ]; then
              yarn package:prod
              exit 0;
            fi

            if [ << parameters.env >> == 'stage' ]; then
              UPGRADES_LINK=$UPGRADES_LINK_STAGE SEGMENT_WRITE_KEY=$SEGMENT_WRITE_KEY_STAGE yarn package:stage
              exit 0;
            fi

            UPGRADES_LINK='' SEGMENT_WRITE_KEY='' yarn package:stage
      - when:
          condition:
            equal: [ true, << parameters.redisstack >> ]
          steps:
            - run:
                name: Repack AppImage to tar
                command: |
                  ARCH=x86_64 ./.circleci/redisstack/app-image.repack.sh
            - run:
                name: Build sources
                command: ./.circleci/redisstack/build.sh
            - run:
                name: Build modules
                command: |
                  PLATFORM=linux ARCH=x64 .circleci/redisstack/build_modules.sh
                  PLATFORM=linux ARCH=arm64 .circleci/redisstack/build_modules.sh
                  PLATFORM=darwin ARCH=x64 .circleci/redisstack/build_modules.sh
                  PLATFORM=darwin ARCH=arm64 .circleci/redisstack/build_modules.sh
      - persist_to_workspace:
          root: .
          paths:
            - release/RedisInsight*.deb
            - release/RedisInsight*.rpm
            - release/RedisInsight*.AppImage
            - release/RedisInsight*.flatpak
            - release/RedisInsight*.snap
            - release/*-linux.yml
            - release/redisstack
  macosx:
    macos:
      xcode: 14.2.0
    parameters:
      env:
        description: Build environment (stage || prod)
        type: enum
        default: stage
        enum: ['stage', 'prod', 'dev']
    steps:
      - checkout
      - node/install:
          node-version: '16.15.1'
      - attach_workspace:
          at: .
      - run:
          command: |
            cp ./electron/package.json ./redisinsight/
      - run:
          name: install dependencies
          command: |
            yarn install
            yarn --cwd redisinsight/api/ install
            yarn build:statics
          no_output_timeout: 15m
      - <<: *keychain
      - run:
          name: Build macos dmg
          command: |
            unset CSC_LINK
            export CSC_IDENTITY_AUTO_DISCOVERY=true
            export CSC_KEYCHAIN=redisinsight.keychain

            if [ << parameters.env >> == 'prod' ]; then
              yarn package:prod
              yarn package:mas
              rm -rf release/mac
              exit 0;
            fi

            if [ << parameters.env >> == 'stage' ]; then
              UPGRADES_LINK=$UPGRADES_LINK_STAGE SEGMENT_WRITE_KEY=$SEGMENT_WRITE_KEY_STAGE yarn package:stage && yarn package:mas
              rm -rf release/mac
              exit 0;
            fi

            UPGRADES_LINK='' SEGMENT_WRITE_KEY='' yarn package:stage && yarn package:mas
            rm -rf release/mac
          no_output_timeout: 60m

      - run:
          name: Repack dmg to tar
          command: |
            ARCH=x64 ./.circleci/redisstack/dmg.repack.sh
            ARCH=arm64 ./.circleci/redisstack/dmg.repack.sh
      - persist_to_workspace:
          root: .
          paths:
            - release/RedisInsight*.zip
            - release/RedisInsight*.dmg
            - release/RedisInsight*.dmg.blockmap
            - release/**/*.pkg
            - release/*-mac.yml
            - release/redisstack
  windows:
    executor:
      name: win/default
    parameters:
      env:
        description: Build environment (stage || prod)
        type: enum
        default: stage
        enum: ['stage', 'prod', 'dev']
    steps:
      - checkout
      - attach_workspace:
          at: .
      - run:
          command: |
            cp ./electron/package.json ./redisinsight/
      - run:
          name: Build windows exe
          command: |
            choco install nodejs --version=16.15.1
            # set ALL_REDIS_COMMANDS=$(curl $ALL_REDIS_COMMANDS_RAW_URL)
            yarn install
            yarn --cwd redisinsight/api/ install
            yarn build:statics:win
            if [ << parameters.env >> == 'prod' ]; then
              yarn package:prod
              rm -rf release/win-unpacked
              exit 0;
            fi

            if [ << parameters.env >> == 'stage' ]; then
              UPGRADES_LINK=$UPGRADES_LINK_STAGE SEGMENT_WRITE_KEY=$SEGMENT_WRITE_KEY_STAGE yarn package:stage
              rm -rf release/win-unpacked
              exit 0;
            fi

            UPGRADES_LINK='' SEGMENT_WRITE_KEY='' yarn package:stage
            rm -rf release/win-unpacked
          shell: bash.exe
          no_output_timeout: 20m
      - persist_to_workspace:
          root: .
          paths:
            - release/RedisInsight*.exe
            - release/RedisInsight*.exe.blockmap
            - release/*.yml
  virustotal:
    executor: linux-executor
    parameters:
      ext:
        description: File extension
        type: string
    steps:
      - checkout
      - attach_workspace:
          at: /tmp/release
      - run:
          name: export FILE_NAME environment variable
          command: |
            echo 'export FILE_NAME="RedisInsight*<< parameters.ext >>"' >> $BASH_ENV
      - <<: *scan
      - <<: *validate
  docker:
    executor: linux-executor
    parameters:
      env:
        type: enum
        default: staging
        enum: ['staging', 'production']
    steps:
      - checkout
      - run:
          name: Build Docker image (API + UI)
          command: |
            TELEMETRY=$SEGMENT_WRITE_KEY_DEV

            if [ << parameters.env >> == 'production' ]; then
              TELEMETRY=$SEGMENT_WRITE_KEY
            fi

            if [ << parameters.env >> == 'staging' ]; then
              TELEMETRY=$SEGMENT_WRITE_KEY_STAGE
            fi

            docker build --build-arg NODE_ENV=<< parameters.env >> \
            --build-arg SERVER_TLS_CERT="$SERVER_TLS_CERT" \
            --build-arg SERVER_TLS_KEY="$SERVER_TLS_KEY" \
            --build-arg SEGMENT_WRITE_KEY="$TELEMETRY" \
            -t riv2:latest .

            mkdir -p docker-release
            docker image save -o docker-release/docker.tar riv2
      - persist_to_workspace:
          root: .
          paths:
            - ./docker-release

  # Release jobs
  store-build-artifacts:
    executor: linux-executor
    steps:
      - attach_workspace:
          at: .
      - store_artifacts:
          path: release
          destination: release
  release-aws-test:
    executor: linux-executor
    steps:
      - checkout
      - attach_workspace:
          at: .
      - run:
          name: publish
          command: |
            rm release/._* ||:
            chmod +x .circleci/redisstack/sum_sha256.sh
            .circleci/redisstack/sum_sha256.sh
            applicationVersion=$(jq -r '.version' redisinsight/package.json)

            aws s3 cp release/ s3://${AWS_BUCKET_NAME_TEST}/public/rs-ri-builds/${CIRCLE_BUILD_NUM} --recursive

  release-aws-private:
    executor: linux-executor
    steps:
      - checkout
      - attach_workspace:
          at: .
      - store_artifacts:
          path: release
          destination: release
      - run:
          name: prepare release
          command: |
            rm release/._* ||:
      - run:
          name: publish
          command: |
            chmod +x .circleci/redisstack/sum_sha256.sh
            .circleci/redisstack/sum_sha256.sh
            applicationVersion=$(jq -r '.version' redisinsight/package.json)

            aws s3 cp release/ s3://${AWS_BUCKET_NAME}/private/${applicationVersion} --recursive

  publish-prod-aws:
    executor: linux-executor
    steps:
      - checkout
      - run:
          name: Init variables
          command: |
            latestYmlFileName="latest.yml"
            downloadLatestFolderPath="public/latest"
            upgradeLatestFolderPath="public/upgrades"
            releasesFolderPath="public/releases"
            appName=$(jq -r '.productName' electron-builder.json)
            appVersion=$(jq -r '.version' redisinsight/package.json)

            echo "export downloadLatestFolderPath=${downloadLatestFolderPath}" >> $BASH_ENV
            echo "export upgradeLatestFolderPath=${upgradeLatestFolderPath}" >> $BASH_ENV
            echo "export releasesFolderPath=${releasesFolderPath}" >> $BASH_ENV
            echo "export applicationName=${appName}" >> $BASH_ENV
            echo "export applicationVersion=${appVersion}" >> $BASH_ENV
            echo "export appFileName=RedisInsight" >> $BASH_ENV

            # download latest.yml file to get last public version
            aws s3 cp s3://${AWS_BUCKET_NAME}/${downloadLatestFolderPath}/${latestYmlFileName} .

            versionLine=$(head -1 ${latestYmlFileName})
            versionLineArr=(${versionLine/:// })
            previousAppVersion=${versionLineArr[1]}

            echo "export previousApplicationVersion=${previousAppVersion}" >> $BASH_ENV

      - run:
          name: Publish AWS S3
          command: |
            # remove previous build from the latest directory /public/latest
            aws s3 rm s3://${AWS_BUCKET_NAME}/${downloadLatestFolderPath} --recursive

            # remove previous build from the upgrade directory /public/upgrades
            aws s3 rm s3://${AWS_BUCKET_NAME}/${upgradeLatestFolderPath} --recursive

            # copy current version apps for download to /public/latest
            aws s3 cp s3://${AWS_BUCKET_NAME}/private/${applicationVersion}/ \
              s3://${AWS_BUCKET_NAME}/${downloadLatestFolderPath} --recursive  --exclude "*.zip"

            # copy current version apps for upgrades to /public/upgrades
            aws s3 cp s3://${AWS_BUCKET_NAME}/private/${applicationVersion}/ \
              s3://${AWS_BUCKET_NAME}/${upgradeLatestFolderPath} --recursive

            # !MOVE current version apps to releases folder /public/releases
            aws s3 mv s3://${AWS_BUCKET_NAME}/private/${applicationVersion}/ \
              s3://${AWS_BUCKET_NAME}/${releasesFolderPath}/${applicationVersion} --recursive

            # invalidate cloudfront cash
            aws cloudfront create-invalidation --distribution-id ${AWS_DISTRIBUTION_ID} --paths "/*"

      - run:
          name: Add tags for all objects and create S3 metrics
          command: |

            # declare all tags
            declare -A tag0=(
                [arch]='x64'
                [platform]='macos'
                [objectDownload]=${applicationName}'-mac-x64.dmg'
                [objectUpgrade]=${applicationName}'-mac-x64.zip'
            )

            declare -A tag1=(
                [arch]='arm64'
                [platform]='macos'
                [objectDownload]=${applicationName}'-mac-arm64.dmg'
                [objectUpgrade]=${applicationName}'-mac-arm64.zip'
            )

            declare -A tag2=(
                [arch]='x64'
                [platform]='windows'
                [objectDownload]=${applicationName}'-win-installer.exe'
            )

            declare -A tag3=(
                [arch]='x64'
                [platform]='linux_AppImage'
                [objectDownload]=${applicationName}'-linux-x86_64.AppImage'
            )

            declare -A tag4=(
                [arch]='x64'
                [platform]='linux_deb'
                [objectDownload]=${applicationName}'-linux-amd64.deb'
            )

            declare -A tag5=(
                [arch]='x64'
                [platform]='linux_rpm'
                [objectDownload]=${applicationName}'-linux-x86_64.rpm'
            )

            # loop for add all tags to each app and create metrics
            declare -n tag
            for tag in ${!tag@}; do

                designation0="downloads"
                designation1="upgrades"

                id0="${tag[platform]}_${tag[arch]}_${designation0}_${applicationVersion}"
                id1="${tag[platform]}_${tag[arch]}_${designation1}_${applicationVersion}"

                # add tags to each app for download
                aws s3api put-object-tagging \
                  --bucket ${AWS_BUCKET_NAME} \
                  --key ${downloadLatestFolderPath}/${tag[objectDownload]} \
                  --tagging '{"TagSet": [{ "Key": "version", "Value": "'"${applicationVersion}"'" }, {"Key": "platform", "Value": "'"${tag[platform]}"'"}, {"Key": "arch", "Value": "'"${tag[arch]}"'"}, { "Key": "designation", "Value": "'"${designation0}"'" }]}'

                # add tags to each app for upgrades
                aws s3api put-object-tagging \
                  --bucket ${AWS_BUCKET_NAME} \
                  --key ${upgradeLatestFolderPath}/${tag[objectUpgrade]:=${tag[objectDownload]}} \
                  --tagging '{"TagSet": [{ "Key": "version", "Value": "'"${applicationVersion}"'" }, {"Key": "platform", "Value": "'"${tag[platform]}"'"}, {"Key": "arch", "Value": "'"${tag[arch]}"'"}, { "Key": "designation", "Value": "'"${designation1}"'" }]}'

                # Create metrics for all tags for downloads to S3
                aws s3api put-bucket-metrics-configuration \
                  --bucket ${AWS_BUCKET_NAME} \
                  --id ${id0} \
                  --metrics-configuration '{"Id": "'"${id0}"'", "Filter": {"And": {"Tags": [{"Key": "platform", "Value": "'"${tag[platform]}"'"}, {"Key": "arch", "Value": "'"${tag[arch]}"'"}, {"Key": "designation", "Value": "'"${designation0}"'"}, {"Key": "version", "Value": "'"${applicationVersion}"'"} ]}}}'

                # Create metrics for all tags for upgrades to S3
                aws s3api put-bucket-metrics-configuration \
                  --bucket ${AWS_BUCKET_NAME} \
                  --id ${id1} \
                  --metrics-configuration '{"Id": "'"${id1}"'", "Filter": {"And": {"Tags": [{"Key": "platform", "Value": "'"${tag[platform]}"'"}, {"Key": "arch", "Value": "'"${tag[arch]}"'"}, {"Key": "designation", "Value": "'"${designation1}"'"}, {"Key": "version", "Value": "'"${applicationVersion}"'"}]}}}'

            done

workflows:
  # FE Unit tests for "fe/feature" or "fe/bugfix" branches only
  frontend-tests:
    jobs:
      - unit-tests-ui:
          name: UTest - UI
          filters:
            branches:
              only:
                - /^fe/feature.*/
                - /^fe/bugfix.*/
  # BE Unit + Integration (limited RTEs) tests for "be/feature" or "be/bugfix" branches only
  backend-tests:
    jobs:
      - unit-tests-api:
          name: UTest - API
          filters:
            branches:
              only:
                - /^be/feature.*/
                - /^be/bugfix.*/
      - integration-tests-run:
          matrix:
            alias: itest-code
            parameters:
              rte: *iTestsNamesShort
          name: ITest - << matrix.rte >> (code)
          requires:
            - UTest - API
  # E2E tests for "e2e/feature" or "e2e/bugfix" branches only
  e2e-tests:
    jobs:
      - approve:
          name: Start E2E Tests
          type: approval
          filters:
            branches:
              only:
                - /^e2e/feature.*/
                - /^e2e/bugfix.*/
      - docker:
          name: Build docker image
          requires:
            - Start E2E Tests
      - e2e-tests:
          name: E2ETest
          build: docker
          parallelism: 4
          requires:
            - Build docker image
  # Workflow for feature, bugfix, main branches
  feature-main-branch:
    jobs:
      # Approve to run all (unit, integration, e2e) tests
      - approve:
          name: Start All Tests
          type: approval
          filters:
            branches:
              only:
                - /^feature.*/
                - /^bugfix.*/
                - main
      # FE tests
      - unit-tests-ui:
          name: UTest - UI
          requires:
            - Start All Tests
      # BE tests
      - unit-tests-api:
          name: UTest - API
          requires:
            - Start All Tests
      - integration-tests-run:
          matrix:
            alias: itest-code
            parameters:
              rte: *iTestsNames
          name: ITest - << matrix.rte >> (code)
          requires:
            - Start All Tests
      - integration-tests-coverage:
          name: ITest - Final coverage
          requires:
            - itest-code
      # E2E tests
      - docker:
          name: Build docker image
          requires:
            - Start All Tests
      - e2e-tests:
          name: E2ETest
          build: docker
          parallelism: 4
          requires:
            - Build docker image
      # Approve to build
      - approve:
          name: Build App
          type: approval
          requires:
            - UTest - UI
            - UTest - API
            - ITest - Final coverage
          filters:
            branches:
              only:
                - /^e2e/feature.*/
                - /^e2e/bugfix.*/
  # build electron app (dev) from "build" branches
  build:
    jobs:
      - setup-sign-certificates:
          name: Setup sign certificates (dev)
          filters:
            branches:
              only:
                - /^build.*/
      - setup-build:
          name: Setup build (dev)
          env: dev
          requires:
            - Setup sign certificates (dev)
      - linux:
          name: Build app - Linux (dev)
          env: dev
          requires: &devBuildRequire
            - Setup build (dev)
      - macosx:
          name: Build app - MacOS (dev)
          env: dev
          requires: *devBuildRequire
      - windows:
          name: Build app - Windows (dev)
          env: dev
          requires: *devBuildRequire
      - store-build-artifacts:
          name: Store build artifacts (dev)
          requires:
            - Build app - Linux (dev)
            - Build app - MacOS (dev)
            - Build app - Windows (dev)
      - release-aws-test:
          name: Release AWS dev
          requires:
            - Build app - Linux (dev)
            - Build app - MacOS (dev)
            - Build app - Windows (dev)
  # Main workflow for release/* and latest branches only
  release:
    jobs:
      # unit tests (on any commit)
      - unit-tests-ui:
          name: UTest - UI
          filters: &releaseAndLatestFilter
            branches:
              only:
                - /^release.*/
                - latest
      - unit-tests-api:
          name: UTest - API
          filters: *releaseAndLatestFilter
      # integration tests
      - integration-tests-run:
          matrix:
            alias: itest-code
            parameters:
              rte: *iTestsNames
          name: ITest - << matrix.rte >> (code)
          filters: *releaseAndLatestFilter
      - integration-tests-coverage:
          name: ITest - Final coverage
          requires:
            - itest-code
        # e2e tests (doesn't affect pipeline even if fail)
      - docker:
          name: Build docker image
          filters: *releaseAndLatestFilter
      - e2e-tests:
          name: E2ETest
          build: docker
          parallelism: 4
          requires:
            - Build docker image


      # ================== STAGE ==================
      # prebuild (stage)
      - setup-sign-certificates:
          name: Setup sign certificates (stage)
          requires:
            - UTest - UI
            - UTest - API
            - ITest - Final coverage
          <<: *stageFilter
      - setup-build:
          name: Setup build (stage)
          requires:
            - Setup sign certificates (stage)
      # build electron app (stage)
      - linux:
          name: Build app - Linux (stage)
          requires: &stageElectronBuildRequires
            - Setup build (stage)
      - macosx:
          name: Build app - MacOS (stage)
          requires: *stageElectronBuildRequires
      - windows:
          name: Build app - Windows (stage)
          requires: *stageElectronBuildRequires
      # release to AWS (stage)
      - release-aws-test:
          name: Release AWS stage
          requires:
            - Build app - Linux (stage)
            - Build app - MacOS (stage)
            - Build app - Windows (stage)
      # Needs approval from QA team that build was tested before merging to latest
      - qa-approve:
          name: Approved by QA team
          type: approval
          requires:
            - Build app - Linux (stage)
            - Build app - MacOS (stage)
            - Build app - Windows (stage)

      # ================== PROD ==================
      # build and release electron app (prod)
      - setup-sign-certificates:
          name: Setup sign certificates (prod)
          requires:
            - UTest - UI
            - UTest - API
            - ITest - Final coverage
          <<: *prodFilter
      - setup-build:
          name: Setup build (prod)
          env: prod
          requires:
            - Setup sign certificates (prod)
      - linux:
          name: Build app - Linux (prod)
          env: prod
          requires: &prodElectronBuildRequires
            - Setup build (prod)
      - macosx:
          name: Build app - MacOS (prod)
          env: prod
          requires: *prodElectronBuildRequires
      - windows:
          name: Build app - Windows (prod)
          env: prod
          requires: *prodElectronBuildRequires
      # virus check all electron apps (prod)
      - virustotal:
          name: Virus check - AppImage (prod)
          ext: .AppImage
          requires:
            - Build app - Linux (prod)
      - virustotal:
          name: Virus check - deb (prod)
          ext: .deb
          requires:
            - Build app - Linux (prod)
      - virustotal:
          name: Virus check x64 - dmg (prod)
          ext: -x64.dmg
          requires:
            - Build app - MacOS (prod)
      - virustotal:
          name: Virus check arm64 - dmg (prod)
          ext: -arm64.dmg
          requires:
            - Build app - MacOS (prod)
      - virustotal:
          name: Virus check - exe (prod)
          ext: .exe
          requires:
            - Build app - Windows (prod)
      # upload release to prerelease AWS folder
      - release-aws-private:
          name: Release AWS S3 Private (prod)
          requires:
            - Virus check - AppImage (prod)
            - Virus check - deb (prod)
            - Virus check x64 - dmg (prod)
            - Virus check arm64 - dmg (prod)
            - Virus check - exe (prod)
      # Manual approve for publish release
      - approve-publish:
          name: Approve Publish Release (prod)
          type: approval
          requires:
            - Release AWS S3 Private (prod)
          <<: *prodFilter # double check for "latest"
      # Publish release
      - publish-prod-aws:
          name: Publish AWS S3
          requires:
            - Approve Publish Release (prod)
          <<: *prodFilter # double check for "latest"
  # Nightly tests
  nightly:
    triggers:
      - schedule:
          cron: '0 0 * * *'
          filters:
            branches:
              only:
                - main
    jobs:
      # build docker image
      - docker:
          name: Build docker image
      # build desktop app
      - setup-sign-certificates:
          name: Setup sign certificates (stage)
      - setup-build:
          name: Setup build (stage)
          requires:
            - Setup sign certificates (stage)
      - linux:
          name: Build app - Linux (stage)
          requires:
            - Setup build (stage)
#      - windows:
#          name: Build app - Windows (stage)
#          requires:
#            - Setup build (stage)
      # integration tests on docker image build
      - integration-tests-run:
          matrix:
            alias: itest-docker
            parameters:
              rte: *iTestsNames
              build: ['docker']
              report: [true]
          name: ITest - << matrix.rte >> (docker)
          requires:
            - Build docker image
      # e2e web tests on docker image build
      - e2e-tests:
          name: E2ETest - Nightly
          parallelism: 4
          build: docker
          report: true
          requires:
            - Build docker image
      # e2e desktop tests on AppImage build
      # - e2e-app-image:
      #     name: E2ETest (AppImage) - Nightly
      #     parallelism: 4
      #     report: true
      #     requires:
      #       - Build app - Linux (stage)
      # # e2e desktop tests on exe build
      # - e2e-exe:
      #     name: E2ETest (exe) - Nightly
      #     parallelism: 4
      #     report: true
      #     requires:
      #       - Build app - Windows (stage)
